#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'dm-core'
require 'Newick'
require 'ostruct'
require 'csv'
require 'ComboDB'
require 'ComboDB-metadata'
require 'ApisDB'

opts = OpenStruct.new

opts.all = false
opts.host = "mysql://access:access@mysql-lan-pro"
opts.storage = "misc_apis"
opts.proteindb = "phylodb"
opts.tree = false
opts.cog = false
opts.len = false

ARGV.options {|o|
  o.banner << " [dataset .. dataset..]"
  o.on("-a", "--all", "include all datasets in database") {|t| opts.all = true}
  o.on("-c", "--cog", "include COG info in file (#{opts.cog})") {|t| opts.cog = t}
  o.on("-h ", "--host ", String, "database host (default #{opts.host})") {|t| opts.host = t}
  o.on("-l", "--length", "include peptide length in file (#{opts.len})") {|t| opts.len = t}
  o.on("-p ", "--proteindb ", String, "protein database (default #{opts.proteindb})") {|t| opts.proteindb = t}
  o.on("-s ", "--storage ", String, "storage database (default #{opts.storage})") {|t| opts.storage = t}
  o.on("-t", "--tree", "include tree in file (#{opts.tree})") {|t| opts.tree = t}
  begin
    o.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts o
    exit(1)
  end
  if (ARGV.size < 1 && !opts.all)
    STDERR.puts o
    exit(1)
  end
}

DataMapper.setup(:default, opts.host + "/" + opts.storage)
DataMapper.setup(:combodb, opts.host + "/" + opts.proteindb)

if (opts.all)
  storage.query("select dataset from dataset").each {|dataset|
    ARGV.push(dataset[0])
  }
end

out = Hash.new

header = ["Seq"]
header.push("Dataset") if ARGV.size > 1
header.push("Length") if (opts.len)
header.push("Taxonomy", "APIS Annotation")
header.push("Cog", "Cog Definition") if (opts.cog)
header.push("Tree") if (opts.tree)

print header.to_csv

ARGV.each do |dataset|
  dataset = Dataset.first(:id => dataset)
  if (!dataset.nil?)
    dataset.sequences.each do |seq|
      row = []
      row.push(seq.name)
      row.push(dataset.id) if ARGV.size > 1
      row.push(seq.sequence.length) if (opts.len)
      if (!seq.tree.nil?)
        row.push(seq.classification.to_s)
      else
        row.push("NO_TREE")
      end
      row.push(seq.annotations.first.to_s)
      row.push(seq.cog) if (opts.cog)
      row.push(seq.tree.to_s) if (opts.tree)
      print row.to_csv
    end
  end
end
