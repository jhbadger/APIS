#!/usr/bin/env ruby

# createApisCSV is a script for generating reports from an existing APIS run, or sets of runs. This output can be in the 
# form of csv file(s) or tab delimited file(s). By default, the sequence name, dataset, seq length, annotation, 
# classification, and NCBI tax id of the classification are reported, but other fields, such as bootstrap value and the
# "relaxed" classification can be included

require 'optparse'
require 'Newick'
require 'ostruct'
require 'csv'
require 'ApisDB'

opt = OpenStruct.new

opt.all = false
opt.storage = "misc_apis"
opt.tree = false
opt.boot = false
opt.cut = false
opt.delim = false
opt.exp = false
opt.file = false
opt.relax = false
opt.limit = false
opt.blast = false
ApisDB.loadOptions(opt)

ARGV.options do |o|
  o.banner << " [dataset .. dataset..]"
  o.on("-a", "--all", "include all datasets in database (#{opt.all})") {opt.all = true}
  o.on("-b", "--bootstrap", "include bootstrap value (#{opt.boot})") {|t| opt.boot = t}
  o.on("-c", "--cut", "separate file per dataset (#{opt.cut})") {opt.cut = true}
  o.on("-d", "--delim-tab", "use tab delimiter (#{opt.delim})") {opt.delim = true}
  o.on("-e ", "--expression ", String, "include datasets matching substring") {|t| opt.exp = t}
  o.on("-f ", "--file ", String, "only include ids from file") {|t| opt.file = t}
  o.on("-h ", "--host ", String, "database host (#{opt.host})") {|t| opt.host = t}
  o.on("-l ", "--limit ", Integer, "number of records to limit to") {|t| opt.limit = t}
  o.on("-r", "--relax", "relaxed classification (#{opt.relax})") {opt.relax = true}
  o.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|t| opt.storage = t}
  o.on("-t", "--tree", "include tree in file (#{opt.tree})") {|t| opt.tree = t}
  o.on("-y", "--blast", "include top BLAST hit (#{opt.blast})") {opt.blast = true}
  begin
    o.parse!
  rescue
    STDERR << $!.message << "\n"
    STDERR << o 
    exit(1)
  end
  if (ARGV.size < 1 && (!opt.all && !opt.exp))
    STDERR << o
    exit(1)
  end
end

db = ApisDB.new(opt.host + "/" + opt.storage)

if (opt.all || opt.exp)
  db.query("select dataset from dataset").each do |row|
    dataset, rest = row
    ARGV.push(dataset.to_s.quote) if (!opt.exp || dataset =~/#{opt.exp}/)
  end
end


if (opt.delim)
  opt.delim = "\t"
else
  opt.delim = ","
end

out = Hash.new

datasets = ARGV


if (!datasets.empty?)
  header = ["Seq Name", "Dataset", "Length", "Annotation", "Standard Classification", "Standard Tax Id"]
  header.push("Relaxed Classification", "Relaxed Tax Id") if opt.relax
  header.push("Bootstrap") if (opt.boot)
  header.push("Tree") if (opt.tree)
  if (opt.blast)
    header.push("Blast ID")
    header.push("Blast Annotation")
    header.push("Blast Evalue")
    header.push("Blast Identity")
    header.push("Blast Coverage")
  end

  if (opt.tree || opt.relax)
    db.tax # load taxonomy
  end

  def summarizeClass(db, tax)
    t = ""
    tid = nil
    goodRank = ""
    tax.each do |rank|
      if (rank !="Undefined" && !rank.nil?)
        t += "; " if t != ""
        t += rank
        break if rank == "Mixed"
      end
      goodRank = rank
    end
    t = "NO_TREE" if t == ""
    if (goodRank != "")
      db.query("SELECT taxon_id FROM phylodb.taxonomy WHERE name = '#{goodRank.to_s.quote}' LIMIT 1").each do |row|
        tid = row.first
      end
    end
    return t, tid
  end


  inClause = ""

  if (opt.file)
    inClause = "("
    STDERR << "Loading file of ids...\n"
    File.new(opt.file).each do |line|
      id, rest = line.chomp.split(" ")
      inClause += "'" + id + "'," if (!id.nil?)
    end
    inClause.chop!
    inClause += ")"
  end

  query = "SELECT count(*) FROM sequence WHERE dataset in ('#{datasets.join('\',\'')}')"
  query += " AND sequence.seq_name IN #{inClause}" if (inClause != "")
  STDERR << "Counting sequences...\n"
  num = db.get(query).first.to_i
  milestone = num / 200.0

  file = STDOUT
  file << header.to_csv({:col_sep=>opt.delim}) if (!opt.cut)
  ext = ".csv"
  ext = ".tab" if (opt.delim)
  count = 0
  STDERR << "Writing Spreadsheet...\n"

  datasets.each do |dataset|
    db.close
    db.connect
    if (opt.cut)
      file.close if file != STDOUT
      file = File.new(dataset + ext, "w")
      file << header.to_csv({:col_sep=>opt.delim})
    end
    query =  "SELECT sequence.seq_name, sequence.dataset, length(sequence), annotation, "
    query += "kingdom, phylum, class, ord, family, genus, species, tree"
    query += " FROM sequence "
    query += "LEFT JOIN classification ON classification.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = classification.dataset " 
    query += "LEFT JOIN tree ON tree.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = tree.dataset " 
    query += "LEFT JOIN annotation ON annotation.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = annotation.dataset and annotation.source='APIS' "
    query += "WHERE sequence.dataset='#{dataset.to_s.quote}'"
    query += " AND sequence.seq_name IN #{inClause}" if (inClause != "")
    query += " LIMIT #{opt.limit}" if (opt.limit)
  
    db.query(query).each do |row|
      tree = row.pop
      begin
        newick = NewickTree.new(tree) if (!tree.nil? && (opt.boot || opt.relax))
      rescue
        newick = nil
      end
      tax, tid = summarizeClass(db, row[4..10])
      if (opt.relax)
        if (tree.nil? || newick.nil?)
          rtax = ""
          rtid = nil
        else
          relax = newick.createClassification(row[0], db.tax, nil, true)
          rtax, rtid = summarizeClass(db, relax)
        end
        row[4..10] = [tax, tid, rtax, rtid]
      else
        row[4..10] = [tax, tid]
      end
      if (opt.boot)
        if (tree.nil? || newick.nil?)
          row.push(nil)
        else
          row.push(newick.findNode(row[0]).parent.name)
        end
      end
      row.push(tree) if (opt.tree)
      if (opt.blast)
        query = "SELECT subject_name, subject_description, evalue, identity, query_start, query_end FROM blast WHERE dataset = '#{dataset.to_s.quote}' AND "
        query += "seq_name = '#{row[0].to_s.quote}' ORDER BY evalue ASC LIMIT 1"
        subject_name, subject_description, evalue = nil, nil, nil
        blastHit = db.get(query)
        if (!blastHit.nil?)
          cov = (1 + (blastHit.pop.to_i - blastHit.pop.to_i).abs) / row[2].to_f
          blastHit.push(cov.round(2)) 
          blastHit[3] = blastHit[3].to_f / 100.0
          row += blastHit
        end
      end
      file << row.to_csv({:col_sep=>opt.delim})
      count += 1
      STDERR << ((count*1000)/num)/10.0 << "% completed...\n" if (count % milestone == 0)
    end
  end
  file.close if file != STDOUT
end
db.close

