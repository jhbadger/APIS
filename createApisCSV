#!/usr/bin/env ruby

# createApisCSV is a script for generating reports from an existing APIS run, or sets of runs. This output can be in the 
# form of csv file(s) or tab delimited file(s). By default, the sequence name, dataset, seq length, annotation, 
# classification, and NCBI tax id of the classification are reported, but other fields, such as bootstrap value and the
# "relaxed" classification can be included

require 'optparse'
require 'Newick'
require 'ostruct'
require 'csv'
require 'ApisDB'

opt = OpenStruct.new

opt.all = false
opt.storage = "misc_apis"
opt.tree = false
opt.boot = false
opt.cut = false
opt.delim = ","
opt.exp = false
opt.file = false
opt.relax = false
opt.limit = false
opt.blast = false
opt.exist = false

ApisDB.loadOptions(opt)

ARGV.options do |o|
  o.banner << " [dataset .. dataset..]"
  o.on("-a", "--all", "include all datasets in database (#{opt.all})") {opt.all = true}
  o.on("-b", "--bootstrap", "include bootstrap value (#{opt.boot})") {|t| opt.boot = t}
  o.on("-c", "--cut", "separate file per dataset (#{opt.cut})") {opt.cut = true}
  o.on("-d", "--delim-tab", "use tab delimiter (default #{opt.delim})") {opt.delim = "\t"}
  o.on("-e ", "--expression ", String, "include datasets matching substring") {|t| opt.exp = t}
  o.on("-f ", "--file ", String, "only include ids from file") {|t| opt.file = t}
  o.on("-h ", "--host ", String, "database host (#{opt.host})") {|t| opt.host = t}
  o.on("-l ", "--limit ", Integer, "number of records to limit to") {|t| opt.limit = t}
  o.on("-p ", "--database ", String, 
       "protein database to use (default #{opt.database})") {|p| opt.database = p}
  o.on("-r", "--relax", "relaxed classification (#{opt.relax})") {opt.relax = true}
  o.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|t| opt.storage = t}
  o.on("-t", "--tree", "include tree in file (#{opt.tree})") {|t| opt.tree = t}
  o.on("-y", "--blast", "include top BLAST hit (#{opt.blast})") {opt.blast = true}
  o.on("-x", "--exist", "exclude already existing files") {opt.exist = true}
  begin
    o.parse!
  rescue
    STDERR << $!.message << "\n"
    STDERR << o 
    exit(1)
  end
  if (ARGV.size < 1 && (!opt.all && !opt.exp))
    STDERR << o
    exit(1)
  end
end

db = ApisDB.new(opt.host + "/" + opt.storage, opt.database)

if (opt.all || opt.exp)
  db.query("select dataset from dataset").each do |row|
    dataset, rest = row
    ARGV.push(dataset.to_s.quote) if (!opt.exp || dataset =~/#{opt.exp}/)
  end
end

out = Hash.new

datasets = ARGV


if (!datasets.empty?)
  header = ["Seq Name", "Dataset", "Length", "Annotation", "Standard Classification", "Standard Tax Id"]
  header.push("Relaxed Classification", "Relaxed Tax Id") if opt.relax
  header.push("Bootstrap") if (opt.boot)
  header.push("Tree") if (opt.tree)
  if (opt.blast)
    header.push("Blast ID")
    header.push("Blast Annotation")
    header.push("Blast Evalue")
    header.push("Blast Identity")
    header.push("Blast Coverage")
  end

  if (opt.tree || opt.relax)
    db.tax # load taxonomy
  end

  def summarizeClass(db, tax)
    t = ""
    tid = nil
    goodRank = ""
    tax.each do |rank|
      if (rank !="Undefined" && !rank.nil?)
        t += "; " if t != ""
        t += rank
        break if rank == "Mixed"
      end
      goodRank = rank
    end
    t = "NO_TREE" if t == ""
    if (goodRank != "")
      db.query("SELECT taxon_id FROM #{db.proteindb}.taxonomy WHERE name = '#{goodRank.to_s.quote}' LIMIT 1").each do |row|
        tid = row.first
      end
    end
    return t, tid
  end


  inClause = ""

  if (opt.file)
    inClause = "("
    STDERR << "Loading file of ids...\n"
    File.new(opt.file).each do |line|
      id, rest = line.chomp.split(" ")
      inClause += "'" + id + "'," if (!id.nil?)
    end
    inClause.chop!
    inClause += ")"
  end

  query = "SELECT count(*) FROM sequence WHERE dataset in ('#{datasets.join('\',\'')}')"
  query += " AND sequence.seq_name IN #{inClause}" if (inClause != "")
  STDERR << "Counting sequences...\n"
  num = db.get(query).first.to_i
  milestone = num / 200.0

  file = STDOUT
  file << header.to_csv({:col_sep=>opt.delim}) if (!opt.cut)
  ext = ".csv"
  ext = ".tab" if (opt.delim == "\t")
  count = 0

  datasets.each do |dataset|
    blastHits = Hash.new
    db.close
    db.connect
    if (opt.cut)
      file.close if file != STDOUT
      next if (File.exist?(dataset + ext) && opt.exist)
      next if (File.exist?(dataset + ext + ".bz2") && opt.exist)
      file = File.new(dataset + ext, "w")
      file << header.to_csv({:col_sep=>opt.delim})
    end
    
    if (opt.blast)
      STDERR.printf("Loading BLAST hits...\n")
      query = "SELECT seq_name, evalue, subject_name, subject_description, identity, "
      query += "query_start, query_end FROM blast AS b1 WHERE dataset='#{dataset}' "
      query += "AND score = (SELECT MAX(score) FROM blast AS b2 WHERE "
      query += "b1.seq_name = b2.seq_name AND b1.dataset = b2.dataset)"
      db.query(query).each do |row|
        name, evalue, subject, desc, identity, s, e = row
        blastHits[name] = [subject, desc, evalue.to_f, identity.to_i/100.0, 1 + (e.to_i - s.to_i).abs]
      end
    end
    
    STDERR << "Writing Spreadsheet...\n"

    query =  "SELECT sequence.seq_name, sequence.dataset, length(sequence), annotation, "
    query += "kingdom, phylum, class, ord, family, genus, species, tree"
    query += " FROM sequence "
    query += "LEFT JOIN classification ON classification.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = classification.dataset " 
    query += "LEFT JOIN tree ON tree.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = tree.dataset " 
    query += "LEFT JOIN annotation ON annotation.seq_name = sequence.seq_name "
    query += "AND sequence.dataset = annotation.dataset and annotation.source='APIS' "
    query += "WHERE sequence.dataset='#{dataset.to_s.quote}'"
    query += " AND sequence.seq_name IN #{inClause}" if (inClause != "")
    query += " LIMIT #{opt.limit}" if (opt.limit)
  
    seen = Hash.new
    db.query(query).each do |row|
      next if seen[row[0]]
      seen[row[0]] = true
      tree = row.pop
      begin
        newick = NewickTree.new(tree) if (!tree.nil? && (opt.boot || opt.relax))
      rescue
        newick = nil
      end
      tax, tid = summarizeClass(db, row[4..10])
      if (opt.relax)
        if (tree.nil? || newick.nil?)
          rtax = ""
          rtid = nil
        else
          relax = newick.createClassification(row[0], db.tax, nil, true)
          rtax, rtid = summarizeClass(db, relax)
        end
        row[4..10] = [tax, tid, rtax, rtid]
      else
        row[4..10] = [tax, tid]
      end
      if (opt.boot)
        if (tree.nil? || newick.nil?)
          row.push(nil)
        else
          row.push(newick.findNode(row[0]).parent.name)
        end
      end
      row.push(tree) if (opt.tree)
      if (opt.blast && blastHits[row[0]])
        mlen = blastHits[row[0]].pop
        blastHits[row[0]].push((mlen / row[2].to_f).round(2))
        row += blastHits[row[0]]
      end
      file << row.to_csv({:col_sep=>opt.delim})
      count += 1
      STDERR << ((count*1000)/num)/10.0 << "% completed...\n" if (count % milestone == 0)
    end
  end
  file.close if file != STDOUT
end
db.close

