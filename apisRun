#!/usr/bin/env ruby

require 'optparse'
require 'apis'
require 'bio'
require 'date'
require 'ostruct'


opt = OpenStruct.new 

opt.annotate = false
opt.maxHits = 50
opt.maxTree = 50
opt.local = false
opt.evalue = 1e-10
opt.include = false
opt.coverage = 0.50
opt.minOrf = 50
opt.project = nil
opt.erase = false
opt.exclude = nil
opt.gridSize = 1000
opt.queue = "medium"
opt.rulemaj = false
opt.storage = ""
opt.clear = false
opt.skipBlast = false
opt.gblocks = false
opt.timelogic = false

ApisDB.loadOptions(opt)

o = OptionParser.new
o.banner << " fasta [fasta...]"
o.on("-a", "--annotate", 
     "annotate peptides phylogenomically") {opt.annotate = true}
o.on("-c", "--clear", "remove old output") {opt.clear = true}
o.on("-e ", "--evalue ", Float, 
     "set BLASTP evalue (default #{opt.evalue})") {|e| opt.evalue = e}
o.on("-f ", "--coverage ", Float, 
     "set min coverage (default #{opt.coverage})") {|f| opt.coverage = f}
o.on("-g", "--gblocks", 
     "Trim with Gblocks (default #{opt.gblocks})") {opt.gblocks = true}
o.on("-h ", "--host ", String, "database host (default #{opt.host})") {|h| opt.host = h}
o.on("-i", "--include", 
     "load more peptides into existing dataset (default #{opt.include})") {opt.include = true}
o.on("-l", "--local", "run BLASTP locally") {opt.local = true}
o.on("-o ", "--orfSize ", Integer, 
     "minimum aa length for DNA ORFs (default #{opt.minOrf})") {|o| opt.minOrf = o}
o.on("-p ", "--project ", String, 
     "JCVI project number for grid blast") {|p| opt.project = p}
o.on("-m ", "--maxHits ", Integer, 
     "max number of BLASTP hits (default #{opt.maxHits})") {|m| opt.maxHits = m}
o.on("-q ", "--queue ", String, 
     "grid queue to use (default #{opt.queue})") {|q| opt.queue = q}
o.on("-r", "--ruleMajority", "use majority classification") {opt.ruleMaj = true}
o.on("-s ", "--storage ", String, "storage database") {|s| opt.storage = s}
o.on("-t ", "--maxTree ", Integer, 
     "max number of seqs in tree (default #{opt.maxTree})") {|t| opt.maxTree = t}
o.on("-v ", "--timelogic ", 
     "use timelogic server:user:password (default #{opt.timelogic})") {|t| opt.timelogic = t}
o.on("-x", "--skipBlast", 
     "skip blast step (default #{opt.skipBlast})") {opt.skipBlast = true}
o.on("-y ", "--exclude ", String,
     "exclude taxonomy matching regexp from run") {|y| opt.exclude = y}
o.on("-z ", "--size ", Integer,  
     "number of sequences per each grid job (default #{opt.gridSize})") {|z| opt.gridSize = z} 
o.on(nil, "--erase", "erase input when done (internal use by grid jobs)") {opt.erase = true}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

if (opt.storage == "")
  STDERR.printf("A storage database must be specified\n")
  exit(1)
end


db = ApisDB.new(opt.host + "/" + opt.storage)

ARGV.each do |fasta|
  prot = asProt(fasta, opt.minOrf)
  dataset, ext = File.basename(prot).gsub("apisRun_","").gsub("_input","").split(".")
  db.deleteDataset("dataset = '#{dataset}'", true) if opt.clear
  database = db.blastdb
  db.createDataset(dataset, ENV["USER"], Date.today.to_s, File.basename(database))
  db.loadPeptides(prot, dataset, opt.include)
  if (opt.timelogic)
    runTimeLogic(prot, db, dataset, opt)
  end
  if (opt.local)
    Bio::FlatFile.new(Bio::FastaFormat, File.new(prot)).each do |seq|
      processPep(db, seq, dataset, opt)
    end
  else
    runGridApis(db, dataset, opt)
  end
  if (opt.erase)
    File.unlink(prot)
  end
end

db.close
