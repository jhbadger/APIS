#!/usr/bin/env ruby

require 'optparse'
require 'apis'
require 'bio'
require 'date'
require 'ostruct'

opt = OpenStruct.new

opt.annotate = false
opt.maxHits = 50
opt.maxTree = 50
opt.local = false
opt.evalue = 1e-10
opt.host = "mysql-lan-pro"
opt.include = false
opt.coverage = 0.50
opt.minOrf = 50
opt.project = nil
opt.erase = false
opt.exclude = nil
opt.gridSize = 1000
opt.queue = "medium"
opt.database = "phylodb"
opt.rulemaj = false
opt.storage = ""
opt.clear = false
opt.skipBlast = false
opt.gblocks = false
opt.timelogic = false
opt.user = "apis"
opt.password = "apis_user"

$VERBOSE = nil

o = OptionParser.new
o.banner << " fasta [fasta...]"
o.on("-a", "--annotate", 
     "annotate peptides phylogenomically") {opt.annotate = true}
o.on("-c", "--clear", "remove old output") {opt.clear = true}
o.on("-d ", "--database ", String, 
     "query database (default #{opt.database})") {|d| opt.database = d}
o.on("-e ", "--evalue ", Float, 
     "set BLASTP evalue (default #{opt.evalue})") {|e| opt.evalue = e}
o.on("-f ", "--coverage ", Float, 
     "set min coverage (default #{opt.coverage})") {|f| opt.coverage = f}
o.on("-g", "--gblocks", 
     "Trim with Gblocks (default #{opt.gblocks})") {opt.gblocks = true}
o.on("-h ", "--host ", String, "database host (default #{opt.host})") {|h| opt.host = h}
o.on("-i", "--include", 
     "load more peptides into existing dataset (default #{opt.include})") {opt.include = true}
o.on("-l", "--local", "run BLASTP locally") {opt.local = true}
o.on("-o ", "--orfSize ", Integer, 
     "minimum aa length for DNA ORFs (default #{opt.minOrf})") {|o| opt.minOrf = o}
o.on("-p ", "--project ", String, 
     "JCVI project number for grid blast") {|p| opt.project = p}
o.on("-m ", "--maxHits ", Integer, 
     "max number of BLASTP hits (default #{opt.maxHits})") {|m| opt.maxHits = m}
o.on("-q ", "--queue ", String, 
     "grid queue to use (default #{opt.queue})") {|q| opt.queue = q}
o.on("-r", "--ruleMajority", "use majority classification") {opt.ruleMaj = true}
o.on("-s ", "--storage ", String, "storage database") {|s| opt.storage = s}
o.on("-t ", "--maxTree ", Integer, 
     "max number of seqs in tree (default #{opt.maxTree})") {|t| opt.maxTree = t}
o.on("-u ", "--user ", String, 
     "db user (default #{opt.user})") {|t| opt.user = t}
o.on("-w ", "--password ", String, 
     "db password (default #{opt.password})") {|t| opt.password = t}
o.on("-v ", "--timelogic ", 
     "use timelogic server:user:password (default #{opt.timelogic})") {|t| opt.timelogic = t}
o.on("-x", "--skipBlast", 
     "skip blast step (default #{opt.skipBlast})") {opt.skipBlast = true}
o.on("-y ", "--exclude ", String,
     "exclude taxonomy matching regexp from run") {|y| opt.exclude = y}
o.on("-z ", "--size ", Integer,  
     "number of sequences per each grid job (default #{opt.gridSize})") {|z| opt.gridSize = z} 
o.on(nil, "--erase", "erase input when done (internal use by grid jobs)") {opt.erase = true}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

if (opt.storage == "")
  STDERR.printf("A storage database must be specified\n")
  exit(1)
end


storage = MyDB.new(opt.host, opt.storage, opt.user, opt.password, opt.database)

ARGV.each {|prot|
  prot = asProt(prot, opt.minOrf)
  dataset, ext = File.basename(prot).gsub("apisRun_","").ggsub("_input","").split(".")
  storage.tax
  storage.blastdb
  database = ""
  storage.deleteDataset("dataset = '#{dataset}'", true) if opt.clear
  storage.query("SELECT updated from #{opt.database}.updated").each {|row|
    database = opt.database + "_" + row[0]
  }
  storage.createDataset(dataset, ENV["USER"], Date.today.to_s, database)
  storage.loadPeptides(prot, dataset, opt.include)
  if (opt.timelogic)
    runTimeLogic(prot, storage, dataset, opt)
  end
  if (opt.local)
    Bio::FlatFile.new(Bio::FastaFormat, File.new(prot)).each {|seq|
      processPep(storage, seq, dataset, opt)
    }
  else
    runGridApis(storage, dataset, opt)
  end
  if (opt.erase)
    File.unlink(prot)
  end
}
storage.close
