#!/usr/bin/env ruby

require 'optparse'
require 'Apis_Active'
require 'Newick'
require 'ostruct'
require 'bio'

opt = OpenStruct.new

opt.all = false
opt.file = false
opt.inverse = false
opt.storage = "misc_apis"
opt.host = "mysql-lan-pro"
opt.user = "access"
opt.password = "access"
opt.split = false
opt.tax = nil
opt.ann = false
opt.taxonomy = nil
opt.exp = nil

ARGV.options {|o|
  o.banner << " [dataset...dataset]"
  o.on("-a", "--all", "dump all datasets") {opt.all = true}
  o.on("-e ", "--expression ", String, "include datasets matching substring") {|t| opt.exp = t}
  o.on("-f ", "--file ", String, 
        "read list of ids to search from file") {|f| opt.file = f}   
  o.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|s| opt.storage = s}
  o.on("-t ", "--taxonomy ", String, "only print with matching taxonomy") {|t| opt.taxonomy = t}
  o.on("-h ", "--host ", String, "database host (default #{opt.host})") {|h| opt.host = h}
  o.on("-u ", "--user ", String, "database user (default #{opt.user})") {|h| opt.user = h}
  o.on("-p ", "--password ", String, "database password (default #{opt.password})") {|h| opt.password = h}
  o.on("-v", "--inverse", "return lines not matching expression") {opt.inverse = true}
  o.on("-x", "--split", "make separate file for each dataset") {opt.split = true}
  begin
    o.parse!
  rescue
    STDERR << $!.message << "\n"
    STDERR << o 
    exit(1)
  end
  if (ARGV.size < 1 && (!opt.all && !opt.exp))
    STDERR << o
    exit(1)
  end
}

ActiveRecord::Base.establish_connection(:adapter  => 'mysql',
:host => opt.host, :username=>opt.user, :password=>opt.password,
:database=>opt.storage)

if (opt.all || opt.exp)
  Apisrun.find_each(:select => "dataset") do |run|
    ARGV.push(run.dataset) if (!opt.exp || run.dataset =~/#{opt.exp}/)
  end
end


picked = Hash.new

if (opt.file)
  STDERR << "Loading file of ids...\n"
  File.new(opt.file).each do |line|
    id, rest = line.chomp.split(" ")
    picked[id] = true
  end
end

file = STDOUT

oldDataset = ""
file = STDOUT
Apisrun.find_each(:conditions => {:dataset=>ARGV}) do |run|
  STDERR << "Writing peptides for #{run.dataset}...\n"
  if (opt.split && run.dataset != oldDataset)
    file.close if file != STDOUT
    file = File.new(run.dataset + ".pep", "w")
  end
  if (opt.taxonomy)
    includeIt = :classification
  else
    includeIt = nil
  end
  run.sequences.includes(includeIt).each do |seq|
    printIt = true
    taxonomy = ""
    printIt = false if (opt.file && (!picked[seq.seq_name]))
    if (opt.taxonomy)
      taxonomy = seq.taxonomy
      printIt = false if (taxonomy !~/#{opt.taxonomy}/)
    end
    printIt = !printIt if opt.inverse
    file.print seq.to_fasta(taxonomy) if printIt
  end
  oldDataset = run.dataset
end
file.close if file != STDOUT


