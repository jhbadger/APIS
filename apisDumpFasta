#!/usr/bin/env ruby

require 'optparse'
require 'ApisDB'
require 'ostruct'

opt = ApisDB.loadoptions

opt.all = false
opt.file = false
opt.inverse = false
opt.storage = "misc_apis"
opt.split = false
opt.tax = nil
opt.ann = false
opt.taxonomy = nil
opt.exp = nil

ARGV.options do |o|
  o.banner << " [dataset...dataset]"
  o.on("-a", "--all", "dump all datasets") {opt.all = true}
  o.on("-e ", "--expression ", String, "include datasets matching substring") {|t| opt.exp = t}
  o.on("-f ", "--file ", String, 
        "read list of ids to search from file") {|f| opt.file = f}   
  o.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|s| opt.storage = s}
  o.on("-t ", "--taxonomy ", String, "only print with matching taxonomy") {|t| opt.taxonomy = t}
  o.on("-h ", "--host ", String, "database host (default #{opt.host})") {|h| opt.host = h}
  o.on("-v", "--inverse", "return lines not matching expression") {opt.inverse = true}
  o.on("-x", "--split", "make separate file for each dataset") {opt.split = true}
  begin
    o.parse!
  rescue
    STDERR << $!.message << "\n"
    STDERR << o 
    exit(1)
  end
  if (ARGV.size < 1 && (!opt.all && !opt.exp))
    STDERR << o
    exit(1)
  end
end

db = ApisDB.new(opt.host + "/" + opt.storage)

if (opt.all || opt.exp)
  db.query("SELECT dataset FROM dataset").each do |row|
    ARGV.push(row[0]) if (!opt.exp || row[0] =~/#{opt.exp}/)
  end
end


picked = Hash.new

if (opt.file)
  STDERR << "Loading file of ids...\n"
  File.new(opt.file).each do |line|
    id, rest = line.chomp.split(" ")
    picked[id] = true
  end
end

file = STDOUT

inClause = "("
ARGV.each do |id|
  inClause += "'" + id.quote + "'," if (!id.nil?)
end
inClause.chop!
inClause += ")"

oldDataset = ""
file = STDOUT
query = "SELECT sequence.seq_name, sequence.dataset, sequence"
query += ", kingdom, phylum, class, ord, genus, species" if opt.taxonomy
query += " FROM sequence "
if (opt.taxonomy)
  query += "LEFT JOIN classification ON (classification.dataset = sequence.dataset"
  query += " AND classification.seq_name = sequence.seq_name)"
end
query += " WHERE sequence.dataset IN #{inClause}"

db.query(query).each do |row|
  seq_name, dataset, seq = row.shift, row.shift, row.shift
  printIt = false
  taxonomy = ""
  if (opt.taxonomy)
    next if row[0].nil?
    if (row.index("Mixed"))
      ranks = row[0..row.index("Mixed")]
    else
      ranks = row
    end
    if (ranks)
      taxonomy = ranks.join("; ") 
      printIt = true if (opt.taxonomy && taxonomy =~/#{opt.taxonomy}/)
      printIt = !printIt if (opt.inverse)
    end
  else
    printIt = true
  end
  STDERR << "Writing peptides for #{dataset}...\n" if (dataset != oldDataset)
  if (opt.split && dataset != oldDataset)
    file.close if file != STDOUT
    file = File.new(dataset + ".pep", "w")
  end
  header = seq_name
  header += " " + taxonomy if opt.taxonomy
  file.print seq.to_fasta(header) if printIt
  oldDataset = dataset
end
file.close if file != STDOUT


