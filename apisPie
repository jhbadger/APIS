#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'gchart'
require 'csv'

# add current directory to load path
$LOAD_PATH.unshift(File.dirname($0))

require 'ApisDB'


opt = OpenStruct.new
opt.all = false
opt.exp = false
opt.level = 2
opt.storage = "misc_apis" 
opt.num = false
opt.prop = false
ApisDB.loadOptions(opt)

ARGV.options do |opts|
  opts.banner << " [dataset .. dataset..]"
  opts.on("-a", "--all", "make graphs for all datasets in database") {|t| opt.all = t}
  opts.on("-e ", "--expression ", String, "include datasets matching substring") {|t| opt.exp = t}
  opts.on("-l ", "--level ", Integer,
          "taxonomic level (default #{opt.level})") {|t| opt.level = t}
  opts.on("-p ", "--property ", String, "metadata property to group by") {|t| opt.prop = t}
  opts.on("-s ", "--storage ", String, "storage database (default #{opt.storage})") {|t| opt.storage = t}
  opts.on("-h ", "--host ", String, "database host (default #{opt.host})") {|t| opt.host = t}
  opts.on("-n", "--numbers", "include numbers on pie chart (default #{opt.num})") {opt.num = true}
  begin
    opts.parse!
  rescue
    STDERR.puts $!.message
    STDERR.puts opts
    exit(1)
  end
  if (ARGV.size < 1 && !opt.all && !opt.prop && !opt.exp)
    STDERR.puts opts
    exit(1)
  end
end

db = ApisDB.new(opt.host + "/" + opt.storage)

fieldNames =  ["kingdom","phylum","class","ord","family","genus","species"]
rank = fieldNames[opt.level]
out = File.new("chart_#{rank}.html", "w")

if (opt.all || opt.exp)
  sets = []
  db.query("SELECT dataset FROM dataset").each do |row|
    dataset, rest = row
    sets.push(dataset) if (!opt.exp || dataset =~/#{opt.exp}/)
  end
else
  sets = ARGV
end

metadata = Hash.new
if (opt.prop)
  sets = []
  query = "SELECT dataset, value FROM metadata WHERE prop = '#{opt.prop}'"
  db.query(query).each do |row|
    dataset, value = row
    metadata[value] = "IN (" if metadata[value].nil?
    sets.push(value) if (!sets.include?(value))
    metadata[value] += "'#{dataset}',"
  end
  metadata.keys.each do |value|
    metadata[value].chop!
    metadata[value] += ")"
  end
end


percents = Hash.new

sets.each do |dataset|
  STDERR.printf("Processing %s...\n", dataset)
  counts = Hash.new
  total = 0
  if (opt.prop)
    query = "SELECT COUNT(*) num, #{rank} FROM classification WHERE dataset #{metadata[dataset]} GROUP BY #{rank}"
  else
    query = "SELECT COUNT(*) num, #{rank} FROM classification WHERE dataset = '#{dataset}' GROUP BY #{rank}"
  end
  db.query(query).each do |row|
    num, taxon = row
    next if taxon == "Undefined"
    counts[taxon] = num.to_i
    total += num.to_i / 100.0
  end
  percents[dataset] = Hash.new
  counts["Misc"] = 0
  percents[dataset]["Misc"] = 0
  
  counts.keys.each do |key|
    percents[dataset][key] = counts[key]/total if total > 0
  end

  counts.keys.each do |key|
    if (percents[dataset][key] < 2 && key != "Misc")
      percents[dataset]["Misc"] += percents[dataset][key]
      counts.delete(key)
      percents[dataset].delete(key)
    end
  end
  percents[dataset].delete("Misc") if (percents[dataset]["Misc"] < 2)  
end

colors = ["#90B8C0","#988CA0","#FF9999","#99FF99","#CE0000",
          "#000063","#5A79A5","#9CAAC6","#DEE7EF","#84596B",
          "#B58AA5","#CECFCE","#005B9A","#0191C8","#74C2E1",
          "#8C8984","#E8D0A9","#B7AFA3","#727B84","#DF9496",
          "#00008B", "#0000CD", "#0000FF", "#006400", "#008000",
          "#008000", "#008080", "#008B8B", "#00BFFF", "#00CED1",
          "#F5FFFA", "#F8F8FF", "#FA8072" "#FAEBD7", "#FAF0E6",
          "#FAFAD2", "#000063","#5A79A5","#9CAAC6","#DEE7EF","#84596B"]

colors *= 5 # provide duplicates of colors to stop running out

taxa = Hash.new
percents.keys.sort.each do |dataset|
  percents[dataset].keys.each do |taxon|
    taxa[taxon] = 0 if taxa[taxon].nil?
    taxa[taxon] += percents[dataset][taxon]
  end
end

colorTaxa = Hash.new
taxa.keys.sort {|x,y| taxa[y] <=> taxa[x]}.each do |taxon|
  colorTaxa[taxon] = colors.shift if (colors.size > 0)
end

radius = 50
x = radius*2
y = radius*2
num = 0


print (["Dataset"] + taxa.keys.sort).to_csv

out.printf("<center><H1>#{rank.capitalize} level breakdown</H1></center><BR>\n")
percents.keys.sort.each do |dataset|
  STDERR.printf("Drawing chart for %s...\n", dataset)
  print ([dataset] + taxa.keys.sort.collect{|x| percents[dataset][x].to_f}).to_csv
  legend = percents[dataset].keys
  data = legend.collect{|x| percents[dataset][x].round(1)}
  glegend = legend.dup
  if (opt.num)
    legend.size.times do |i|
      glegend[i] = legend[i] + " " + ((100*data[i]).to_i/100.0).to_s + "%"
    end
  end
  url = Gchart.pie(:data => data, :legend => glegend, :width=>500, :title => dataset)
  col = ""
  legend.each do |key|
    col += colorTaxa[key].downcase.gsub("#","") + ","
  end
  col.chop!
  out.printf("<img src=\"%s&chco=%s\"/>\n\n", url, col)
end
out.close
