#!/usr/bin/env ruby

require 'rubygems'
require 'Newick'
require 'optparse'
require 'csv'
require 'ostruct'

# add current directory to load path
$LOAD_PATH.unshift(File.dirname($0))

require 'ApisDB'

opt = OpenStruct.new
opt.target = false
opt.ingroup = false
opt.only = false
opt.file = nil
opt.name = false
opt.exclude = false
opt.must = false
opt.storage = "misc_apis"
opt.verbose = false
ApisDB.loadOptions(opt)

o = OptionParser.new
o.banner << " dataset"
o.on("-d ", "--database ", String, 
     "protein database to use (default #{opt.proteindb})") {|d| opt.proteindb = d}
o.on("-e ", "--exclude ", String, "exclude from target") {|e| opt.exclude = e}
o.on("-h ", "--host ", String, 
     "database host (default #{opt.host})") {|h| opt.host = h}
o.on("-i ", "--ingroup ", String, "ingroup taxa") {|i| opt.ingroup = i}
o.on("-m ", "--must ", String, 
     "taxon that must come before target") {|m| opt.must = m}
o.on("-n", "--name", "Use name not taxonomy (#{opt.name})") {opt.name = true}
o.on("-o", "--only", "target clade only has target") {opt.only  = true}
o.on("-t ", "--target ", String, "target taxon") {|t| opt.target = t}
o.on("-s ", "--storage ", String, 
     "storage database (default #{opt.storage})") {|s| opt.storage = s}
o.on("-v", "--verbose", "be verbose") {opt.verbose  = true}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

if (!opt.target)
  STDERR.printf("Must supply query and target!\n")
  exit(1)
end

dataset = ARGV.pop

# convert non-standard groups to standard
def convertTax(entry)
  return false if !entry
  entry.gsub!("prokaryotes", "Bacteria|Archaea")
  entry.gsub!("stramenopiles", "Bacillariophyta|Bicosoecida|Pelagophyceae|Peronosporales|Phaeophyceae|Synurophyceae")
  entry.gsub!("diatoms", "Bacillariophyta")
  return entry
end

# summarize set of matching taxonomies
def summarizeTax(consense)
  num = consense.first.size
  match = []
  done = false
  num.times do |i|
    match[i] = ""
    consense.each do |tax|
      tax = tax.split("; ")
      if (match[i] == "")
        match[i] = tax[i]
      elsif (match[i] != tax[i])
        done = true
        break
      end
    end
    break if done
  end
  summary = ""
  match.each do |m|
    break if m.nil?
    summary += "; " if summary != ""
    summary += m
  end
  return summary
end

db = ApisDB.new(opt.host + "/" + opt.storage)
db.loadTaxonomy(opt.proteindb)
tax = db.fullSpeciesTaxonomyHash

STDERR << "Loading Trees...\n"

treeCount = db.get("SELECT count(*) FROM tree WHERE dataset = '#{dataset.quote}'").first.to_i

opt.target = convertTax(opt.target) 
opt.ingroup = convertTax(opt.ingroup)
opt.exclude = convertTax(opt.exclude)
opt.must = convertTax(opt.must)

print ["Id", "Tree", "Target", "Bootstrap", "Annotation"].to_csv
count = 0
db.query("SELECT seq_name, tree FROM tree WHERE dataset = '#{dataset}'").each do |row|
  seq_name, tree = row
  begin
    root =  NewickTree.new(tree).root
  rescue
    STDERR << "Cannot parse tree for #{seq_name}...\n"
    next
  end
  alltaxa = root.taxa.size
  query = root.findNode(seq_name)
  count += 1
  STDERR.printf("%4.2f%% done...\n", count*100.0/treeCount) if (count % 1000 == 0)
  if (!query.nil?)
    found = false
    only = true
    ingroup = true
    must = false
    boot = 100
    while (query != nil && query.taxa.size < alltaxa)
      consense = []
      p query.taxa
      query.taxa.each do |taxon|
        next if taxon == seq_name
        taxsp = taxon.split(/-|__/)[1]
        if (!opt.name)
          tname = tax[taxsp]
        else
          tname = taxon
        end
        if (!opt.ingroup || tname !~/#{opt.ingroup}/ || tname =~/#{opt.target}/)
          ingroup = false 
        end
        if (opt.must && tname =~/#{opt.must}/)
          must = true
          if (opt.verbose)
            STDERR.printf("Must requirement met by #{tname}\n")
          end
        end
        if (tname =~/#{opt.target}/ && tname !~/#{opt.exclude}/ && !ingroup)
          if (!found)
            found = true
            if (opt.verbose)
              STDERR.printf("Found target at %s\n", tname)
            end
            consense = [tname]
          else
            consense.push(tname)
          end
          if (query.name.to_i > 0)
            boot = query.name.to_i
          end
        elsif (tname !~/#{opt.ingroup}/ && tname !~/#{opt.exclude}/)
          only = false
          if (found && opt.verbose && opt.only)
            STDERR.printf("%s fails only criteron\n", tname)
          end
        end
      end
      break if (found && (!opt.only || only))
      break if (opt.ingroup && !ingroup)
      query = query.parent
    end
    if (found && ((only || !opt.only) || ingroup))
      if (must || !opt.must)
        tid = seq_name
        ann = db.get("SELECT annotation FROM annotation WHERE seq_name = '#{seq_name.quote}' AND dataset = '#{dataset.quote}' AND source = 'APIS'")
        print [tid, root.to_s, summarizeTax(consense), boot, ann.first].to_csv
      end
    end
  end
end
