#!/usr/bin/env ruby

require 'rubygems'
require 'dm-core'
require 'Newick'
require 'optparse'
require 'ApisDB'
require 'ComboDB'
require 'csv'
require 'ostruct'

opt = OpenStruct.new
opt.target = false
opt.contig = false
opt.ingroup = false
opt.only = false
opt.file = nil
opt.name = false
opt.exclude = false
opt.must = false
opt.host = "mysql://access:access@mysql-lan-pro"
opt.database = "phylodb"
opt.storage = "misc_apis"
opt.verbose = false

o = OptionParser.new
o.banner << " dataset"
o.on("-c", "--contig", "don't show contig (false)") {opt.contig = true}
o.on("-d ", "--database ", String, 
     "query database (default #{opt.database})") {|d| opt.database = d}
o.on("-e ", "--exclude ", String, "exclude from target") {|e| opt.exclude = e}
o.on("-h ", "--host ", String, 
     "database host (default #{opt.host})") {|h| opt.host = h}
o.on("-i ", "--ingroup ", String, "ingroup taxa") {|i| opt.ingroup = i}
o.on("-m ", "--must ", String, 
     "taxon that must come before target") {|m| opt.must = m}
o.on("-n", "--name", "Use name not taxonomy (#{opt.name})") {opt.name = true}
o.on("-o", "--only", "target clade only has target") {opt.only  = true}
o.on("-t ", "--target ", String, "target taxon") {|t| opt.target = t}
o.on("-s ", "--storage ", String, 
     "storage database (default #{opt.storage})") {|s| opt.storage = s}
o.on("-v", "--verbose", "be verbose") {opt.verbose  = true}
begin
  o.parse!
rescue
  STDERR << $!.message << "\n"
  STDERR << o
  exit(1)
end
if (ARGV.size < 1)
  STDERR << o
  exit(1)
end

if (!opt.target)
  STDERR.printf("Must supply query and target!\n")
  exit(1)
end

dataset = ARGV.pop

# convert non-standard groups to standard
def convertTax(entry)
  return false if !entry
  entry.gsub!("prokaryotes", "Bacteria|Archaea")
  entry.gsub!("stramenopiles", "Bacillariophyta|Bicosoecida|Pelagophyceae|Peronosporales|Phaeophyceae|Synurophyceae")
  entry.gsub!("diatoms", "Bacillariophyta")
  return entry
end

# summarize set of matching taxonomies
def summarizeTax(consense)
  num = consense.first.size
  match = []
  done = false
  num.times do |i|
    match[i] = ""
    consense.each do |tax|
      tax = tax.split("; ")
      if (match[i] == "")
        match[i] = tax[i]
      elsif (match[i] != tax[i])
        done = true
        break
      end
    end
    break if done
  end
  summary = ""
  match.each do |m|
    break if m.nil?
    summary += "; " if summary != ""
    summary += m
  end
  return summary
end

DataMapper.setup(:default, opt.host + "/" + opt.storage)
DataMapper.setup(:combodb, opt.host + "/" + opt.database)

species = Hash.new
taxonomy = Hash.new
STDERR << "Loading Contig Info...\n"
repository(:combodb) {Contig.all}.each do |contig|
  species[contig.name] = contig.species
  taxonomy[contig.name] = contig.taxonomy
end
STDERR << "Loading Trees...\n"
trees = Tree.all(:dataset_id => dataset)

opt.target = convertTax(opt.target) 
opt.ingroup = convertTax(opt.ingroup)
opt.exclude = convertTax(opt.exclude)
opt.must = convertTax(opt.must)

print ["Id", "Tree", "Target", "Bootstrap", "Annotation"].to_csv
count = 0
trees.each do |tree|
  root =  NewickTree.new(tree.tree).root
  alltaxa = root.taxa.size
  query = root.findNode(tree.seq_name)
  count += 1
  STDERR.printf("%4.2f%% done...\n", count*100.0/trees.size) if (count % 1000 == 0)
  if (!query.nil?)
    found = false
    only = true
    ingroup = true
    must = false
    boot = 100
    while (query != nil && query.taxa.size < alltaxa)
      consense = []
      query.taxa.each do |taxon|
        next if taxon == tree.seq_name
        if (!opt.name)
          tname = taxonomy[taxon.split(/-|__/)[1]]
        else
          tname = taxon
        end
        if (!opt.ingroup || tname !~/#{opt.ingroup}/ || tname =~/#{opt.target}/)
          ingroup = false 
        end
        if (opt.must && tname =~/#{opt.must}/)
          must = true
          if (opt.verbose)
            STDERR.printf("Must requirement met by #{tname}\n")
          end
        end
        if (tname =~/#{opt.target}/ && tname !~/#{opt.exclude}/ && !ingroup)
          if (!found)
            found = true
            if (opt.verbose)
              STDERR.printf("Found target at %s\n", tname)
            end
            consense = [tname]
          else
            consense.push(tname)
          end
          if (query.name.to_i > 0)
            boot = query.name.to_i
          end
        elsif (tname !~/#{opt.ingroup}/ && tname !~/#{opt.exclude}/)
          only = false
          if (found && opt.verbose && opt.only)
            STDERR.printf("%s fails only criteron\n", tname)
          end
        end
      end
      break if (found && (!opt.only || only))
      break if (opt.ingroup && !ingroup)
      query = query.parent
    end
    if (found && ((only || !opt.only) || ingroup))
      if (must || !opt.must)
        tid = tree.seq_name
        tid = tid.split("-").first.gsub("ORF","") if opt.contig
        print [tid, tree.tree.chomp, summarizeTax(consense), boot,
              tree.sequence.annotations.first(:source => "APIS")].to_csv
      end
    end
  end
end
